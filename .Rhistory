axis.text.y = element_text(size = 10),
axis.text.x = element_text(size = 10)
)
ggplot(cyclones_data %>% filter(!is.na(category)), aes(x = km_distance_from_equator, y = category, fill = category)) +
geom_density_ridges(scale = 2, alpha = 0.7, color = "black") +
annotate("rect", xmin = 1500, xmax = 2500, ymin = 0, ymax = Inf, fill = "orange", alpha = 0.8) +
labs(
x = "Distance from Equator (km)",
y = "Cyclone Category",
title = "Ridgeline Plot of Distance from Equator by Cyclone Category"
) +
coord_cartesian(xlim = c(0, 6500)) +
theme_minimal() +
theme(
legend.position = "none",
panel.grid.major = element_line(color = "grey80"),
panel.grid.minor = element_blank(),
axis.text.y = element_text(size = 10),
axis.text.x = element_text(size = 10)
)
happiness <- happiness %>%
left_join(
rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
transmute(
country = name_long,
distance_to_equator_km = geosphere::distGeo(
cbind(st_coordinates(st_centroid(geometry))[,1], st_coordinates(st_centroid(geometry))[,2]),
cbind(st_coordinates(st_centroid(geometry))[,1], 0)
) / 1000  # Convert to km
),
by = "country"
)
happiness
happiness_bands_gdp <- happiness %>%
mutate(distance_band = cut(distance_to_equator_km.y, breaks = seq(0, 10000, by = 500), include.lowest = TRUE, labels = seq(0, 9500, by = 500))) %>%
group_by(distance_band) %>%
summarize(avg_log_gdp_per_capita = mean(log_gdp_per_capita, na.rm = TRUE))
# Plot for log GDP per capita
ggplot(happiness_bands_gdp, aes(x = distance_band, y = avg_log_gdp_per_capita)) +
geom_bar(stat = "identity", fill = "steelblue") +
annotate("rect", xmin = "1500", xmax = "2500", ymin = 0, ymax = Inf, fill = "orange", alpha = 0.8) +
labs(
title = "Average GDP per Capita by Distance from Equator",
x = "Distance from Equator (km, Binned)",
y = "Average Log GDP per Capita"
) +
scale_x_discrete(breaks = seq(0, 9500, by = 1000)) +
coord_cartesian(ylim = c(min(happiness_bands_gdp$avg_log_gdp_per_capita, na.rm = TRUE) - 0.1,
max(happiness_bands_gdp$avg_log_gdp_per_capita, na.rm = TRUE) + 0.1)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
# Group data into 500 km distance bands and calculate average life ladder score for each band
happiness_bands_life <- happiness %>%
mutate(distance_band = cut(distance_to_equator_km.y, breaks = seq(0, 10000, by = 500), include.lowest = TRUE, labels = seq(0, 9500, by = 500))) %>%
group_by(distance_band) %>%
summarize(avg_life_ladder = mean(life_ladder, na.rm = TRUE))
# Plot for life ladder
ggplot(happiness_bands_life, aes(x = distance_band, y = avg_life_ladder)) +
geom_bar(stat = "identity", fill = "steelblue") +
annotate("rect", xmin = "1500", xmax = "2500", ymin = 0, ymax = Inf, fill = "orange", alpha = 0.8) +
labs(
title = "Average Life Ladder Score by Distance from Equator",
x = "Distance from Equator (km, Binned)",
y = "Average Life Ladder Score"
) +
scale_x_discrete(breaks = seq(0, 9500, by = 1000)) +
coord_cartesian(ylim = c(min(happiness_bands_life$avg_life_ladder, na.rm = TRUE) - 0.1,
max(happiness_bands_life$avg_life_ladder, na.rm = TRUE) + 0.1)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
# Put in your code to load in the data set, along with any
# necessary cleaning beyond what was done in Part 1
cyclones_data <- read_parquet("cyclones_data.parquet")
# echo = FALSE will set the Rmd to *not* show the R code. Don't change this.
# You may change the default figure width and figure height as you please.
knitr::opts_chunk$set(echo = FALSE, message = FALSE, fig.width = 6)
# Put any libraries that you need to load here.
# DO NOT PUT "install.packages()" IN AN RMD FILE!!!
library(tidyverse)
library(arrow)
library(maps)
library(tinytex)
library(sf)
library(rnaturalearth)
library(corrplot)
library(scales)
library(geosphere)
library(ggridges)
# Put in your code to load in the data set, along with any
# necessary cleaning beyond what was done in Part 1
cyclones_data <- read_parquet("cyclones_data.parquet")
climate_awareness <- read_parquet("climate_awareness.parquet")
world <- ne_countries(scale = "medium", returnclass = "sf")
# ________________Map long and lat to scale________________
# Convert latitude(-90/+90) and longitude(-180/+180) to be within the correct range
cyclones_data <- cyclones_data |>
rename(long = lon) |> #rename lon to long to match with world map
mutate(
lat = ((lat + 90) %% 180) - 90,
long = ((long + 180) %% 360) - 180
)
# ________________Determine distance of cyclone to equator________________
equator_point <- c(0, 0)
cyclones_data <- cyclones_data %>%
mutate(
km_distance_from_equator = distGeo(cbind(long, lat), cbind(long, 0)) / 1000
)
# ________________Determine distance of cyclone to equator________________
equator_point <- c(0, 0)
cyclones_data <- cyclones_data %>%
mutate(
km_distance_from_equator = distGeo(cbind(long, lat), cbind(long, 0)) / 1000
)
# ________________Convert long and lat points to countries________________
cyclones_data <- st_as_sf(cyclones_data, coords = c("long", "lat"), crs = 4326, remove = FALSE) |>
st_join(world["name"], left = TRUE)
# ________________Find countries without storm points________________
countries_with_cyclone <- cyclones_data |>
filter(!is.na(name)) |>
group_by(name) |>
summarise(count = n()) |>
rename(country = name)
countries_without_cyclone <- world |>
st_drop_geometry() |>
select(name) |>
rename(country = name) |>
anti_join(countries_with_cyclone, by = "country")
cyclone_affected <- climate_awareness |>
inner_join(countries_with_cyclone, by = "country") |>
rename(cyclone_count = count) |>
mutate(affected = "Affected")
cyclone_unaffected <- climate_awareness |>
anti_join(countries_with_cyclone, by = "country") |>
mutate(affected = "Unaffected")
# ________________Weight awareness data to countries with more storms________________
weighted_cyclone_affected <- cyclone_affected |>
summarise(
aware_no = sum(aware_no * cyclone_count) / sum(cyclone_count),
aware_alittle = sum(aware_alittle * cyclone_count) / sum(cyclone_count),
aware_moderate = sum(aware_moderate * cyclone_count) / sum(cyclone_count),
aware_alot = sum(aware_alot * cyclone_count) / sum(cyclone_count),
aware_refuse = sum(aware_refuse * cyclone_count) / sum(cyclone_count)
)
world_cyclone <- bind_rows(
weighted_cyclone_affected |>
mutate(affected = "Affected"),
cyclone_unaffected |>
summarise(across(where(is.numeric), mean, na.rm = TRUE)) |>
select(-(aware_base)) |>
mutate(affected = "Unaffected")
)
world_cyclone_long <- world_cyclone |>
pivot_longer(cols = c(aware_no, aware_alittle, aware_moderate, aware_alot, aware_refuse),
names_to = "awareness_level", values_to = "value") |>
mutate(awareness_level = factor(awareness_level,
levels = c("aware_alot", "aware_moderate", "aware_alittle", "aware_no", "aware_refuse"),
labels = c("Aware", "Moderately Aware", "Aware a Little", "Not Aware", "Refuse")))
cyclones_data
world_cyclone
# Note that the code in this document will not be shown
# when you click "knit", so the placement of this code
# chunk is purely for your benefit: You can see what happened
# with your data, which makes it easier to describe below!
# Put in your code to load in the data set, along with any
# necessary cleaning beyond what was done in Part 1
ice_extent_yearly <- read_parquet("ice_extent_yearly.parquet")
ice_extent_yearly
ggplot(ice_extent_yearly, aes(x = year, y = value, color = name)) +
geom_line() +
facet_wrap(~ region) +
labs(
title = "Yearly Ice Extent (Min and Max) for Arctic and Antarctic Regions",
x = "Year",
y = "Ice Extent (in million square kilometers)"
) +
theme_minimal()
# Reminder: do NOT print your data to the screen unless it's
# completely necessary
# Put in your code to load in the data set, along with any
# necessary cleaning beyond what was done in Part 1
climate_awareness <- read_parquet("climate_awareness.parquet")
world_map <- ne_countries(scale = "medium", returnclass = "sf")
climate_awareness <- climate_awareness |>
mutate(country = case_when(
country == "United.States" ~ "United States of America",
country == "United.Kingdom" ~ "UK",
country == "United.Arab.Emirates" ~ "UAE",
country == "Trinidad.and.Tobago" ~ "Trinidad",
country == "Sri.Lanka" ~ "Sri Lanka",
country == "Bolivia.(Plurinational.State.of)" ~ "Bolivia",
country == "Bosnia.and.Herzegovina" ~ "Bosnia",
country == "Congo.(Democratic.Republic.of.the)" ~ "Congo",
country == "Costa.Rica" ~ "Costa Rica",
country == "Cote.d'Ivoire" ~ "Ivory Coast",
country == "Czechia" ~ "Czech Republic",
country == "Dominican.Republic" ~ "Dominican Republic",
country == "El.Salvador" ~ "El Salvador",
country == "Hong.Kong" ~ "Hong Kong",
country == "Lao.People's.Democratic.Republic" ~ "Laos",
country == "New.Zealand" ~ "New Zealand",
country == "Puerto.Rico" ~ "Puerto Rico",
country == "North.MAcedonia" ~ "Macedonia",
country == "Saudi.Arabia" ~ "Saudi Arabia",
country == "South.Africa" ~ "South Africa",
country == "South.Korea" ~ "South Korea",
country == "Antigua" ~ "Antigua and Barbuda",
TRUE ~ country
))
climate_awareness
# Put in your code to load in the data set, along with any
# necessary cleaning beyond what was done in Part 1
covid_2020 <- read_parquet("covid_2020.parquet")
covid_2020
# Put in your code to load in the data set, along with any
# necessary cleaning beyond what was done in Part 1
happiness <- read_parquet("happiness.parquet")
happiness_mapped <- happiness |>
mutate(country = case_when( #match country names to world_map
country == "United States" ~ "United States of America",
country == "United Kingdom" ~ "UK",
country == "Congo (Brazzaville)" ~ "Congo",
country == "Congo (Kinshasa)" ~ "Congo",
country == "Hong Kong S.A.R. of China" ~ "Hong Kong",
country == "Türkiye" ~ "Turkey",
country == "Lao.People's.Democratic.Republic" ~ "Laos",
country == "United Arab Emirates" ~ "UAE",
TRUE ~ country
)) |>
right_join(world_map, by = c("country" = "region")) #joins the long and lat of the respective countries to map them
# Put in your code to load in the data set, along with any
# necessary cleaning beyond what was done in Part 1
happiness <- read_parquet("happiness.parquet")
world_map <- map_data("world")
happiness_mapped <- happiness |>
mutate(country = case_when( #match country names to world_map
country == "United States" ~ "United States of America",
country == "United Kingdom" ~ "UK",
country == "Congo (Brazzaville)" ~ "Congo",
country == "Congo (Kinshasa)" ~ "Congo",
country == "Hong Kong S.A.R. of China" ~ "Hong Kong",
country == "Türkiye" ~ "Turkey",
country == "Lao.People's.Democratic.Republic" ~ "Laos",
country == "United Arab Emirates" ~ "UAE",
TRUE ~ country
)) |>
right_join(world_map, by = c("country" = "region")) #joins the long and lat of the respective countries to map them
world <- ne_countries(scale = "medium", returnclass = "sf")
equator <- st_sfc(st_linestring(rbind(c(-180, 0), c(180, 0))), crs = st_crs(world))
world <- st_transform(world, crs = 3857)
equator <- st_transform(equator, crs = 3857)
happiness <- happiness |>
left_join(
world |>
mutate(
centroid = st_centroid(geometry),
latitude = st_coordinates(centroid)[, 2],
hemisphere = ifelse(latitude > 0, "North", "South"),
distance_to_equator_km = as.numeric(st_distance(centroid, equator)) / 1000
) |>
select(name, hemisphere, distance_to_equator_km) |>
rename(country = name),
by = "country"
)
happiness
# This is an example of how you can control figures and captions in
# an R chunk. Note that you can reference figures using:
# \@ref(fig:insight1), where "insight1" is the label of this code
# chunk (the first bit of text after the "r" in "```{r label, options...}")
world_map <- map_data("world")
ex <- ggplot() +
geom_polygon(data = world_map, aes(x = long, y = lat, group = group), fill = "lightgray", color = "white") +
# hurricanes +-5 of equator are extremely rare
geom_rect(aes(xmin = -180, xmax = 180, ymin = -5, ymax = 5), fill = "red", alpha = 0.2) +
geom_hex(data = cyclones_data, aes(x = long, y = lat, fill = category), bins = 50, alpha = 0.7) +
scale_fill_viridis_d(name = "Storm Category") +
labs(
title = "North Atlantic and Northeast Pacific Cyclones by Category",
x = "Longitude",
y = "Latitude"
) +
scale_x_continuous(breaks = c(-180, -90, 0, 90, 180)) +
scale_y_continuous(breaks = c(-90, -45, 0, 45, 90)) +
theme_minimal()
ggplot(world_cyclone_long, aes(x = awareness_level, y = value, fill = affected)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Awareness Category", y = "% Awareness Level", fill = "Cyclone Impact",
title = "Comparison of Awareness Levels Between Cyclone-Affected and Unaffected") +
theme_minimal()
#Social support & life ladder
data_combined <- inner_join(covid_2020, happiness, by = "country")
median_social_support <- median(data_combined$social_support, na.rm = TRUE)
ggplot(data_combined, aes(x = social_support, y = life_ladder, color = continent)) +
geom_point(alpha = 0.7, position = "jitter") +
geom_smooth(method = "lm", color = "blue", se = TRUE) +
geom_vline(xintercept = median_social_support, color = "red", linetype = "dashed", linewidth = 1) +
labs(
title = "Comparison of Social Support and Life Ladder by Continent",
x = "Social Support",
y = "Life Ladder (Happiness Score)",
color = "Continent"
) +
facet_wrap(~ continent) +
theme_minimal() +
theme(panel.grid.major = element_line(color = "grey", linetype = "dashed", linewidth = 0.5))
# Social Support & Life Expectancy
ggplot(data_combined, aes(x = social_support, y = healthy_life_expectancy_at_birth, color = continent)) +
geom_point(alpha = 0.7, position = "jitter") +
geom_smooth(method = "lm", color = "blue", se = TRUE) +
geom_vline(xintercept = median_social_support, color = "red", linetype = "dashed", linewidth = 1) +
labs(
title = "Comparison of Social Support and Life Expectancy by Continent",
x = "Social Support",
y = "Healthy Life Expectancy at Birth",
color = "Continent"
) +
facet_wrap(~ continent) +
theme_minimal() +
theme(panel.grid.major = element_line(color = "grey", linetype = "dashed", linewidth = 0.5))
data_combined <- inner_join(covid_2020, happiness, by = "country")
median_total_cases <- median(data_combined$total_cases, na.rm = TRUE)
ggplot(data_combined, aes(x = total_cases / 100, y = freedom_to_make_life_choices)) +
geom_point(alpha = 0.5, position = "jitter") +
geom_smooth(method = "lm", color = "blue", se = TRUE) +
geom_vline(xintercept = median_total_cases, color = "red", linetype = "dashed", linewidth = 1) +
labs(
title = "Comparison of COVID-19 Cases and Freedom",
x = "Total COVID-19 Cases",
y = "Freedom"
) +
scale_x_log10() +
scale_y_log10() +
theme_minimal() +
theme(panel.grid.major = element_line(color = "grey", linetype = "dashed", linewidth = 0.5))
#Life expectancy & Cyclone count
cyclone_counts <- cyclones_data |>
group_by(name) |>
summarise(cyclone_count = n()) |>
rename(country = name)
combined_data <- cyclone_counts |>
inner_join(happiness, by = "country") |>
select(country, cyclone_count, healthy_life_expectancy_at_birth)
combined_data <- combined_data |>
arrange(desc(cyclone_count)) |>
slice(-1:-3)
ggplot(combined_data, aes(y = cyclone_count, x = healthy_life_expectancy_at_birth)) +
geom_point(alpha = 0.7) +
geom_smooth(method = "lm", se = TRUE, color = "blue") +
labs(
title = "Relationship Between Cyclone Count and Life Expectancy (Outlier Removed)",
x = "Cyclone Count",
y = "Healthy Life Expectancy at Birth"
) +
theme_minimal()
colnames(happiness)
# distance & cyclone count
# Load required libraries
library(tidyverse)
# Step 1: Aggregate cyclone counts by country
cyclone_counts <- cyclones_data %>%
group_by(name) %>%
summarise(cyclone_count = n()) %>%
rename(country = name)
# Step 2: Join with happiness data on 'country' to add distance from the equator
combined_data <- cyclone_counts %>%
inner_join(happiness, by = "country") %>%
select(country, cyclone_count, distance_to_equator_km)
# Step 3: Remove the top 3 highest cyclone counts
combined_data <- combined_data %>%
arrange(desc(cyclone_count)) %>%
slice(-1:-3)
# Step 4: Plot the relationship between distance to equator and cyclone count
ggplot(combined_data, aes(x = distance_to_equator_km, y = cyclone_count)) +
geom_point(alpha = 0.7, color = "blue") +
geom_smooth(method = "lm", color = "red", se = TRUE) +
labs(
title = "Comparison of Cyclone Count and Distance from Equator (Top 3 Outliers Removed)",
x = "Distance from Equator (km)",
y = "Cyclone Count"
) +
theme_minimal()
ggplot(cyclones_data %>% filter(!is.na(category)), aes(x = km_distance_from_equator, y = category, fill = category)) +
geom_density_ridges(scale = 2, alpha = 0.7, color = "black", size = 0.3) +
labs(
x = "Distance from Equator (km)",
y = "Cyclone Category",
title = "Ridgeline Plot of Distance from Equator by Cyclone Category"
) +
coord_cartesian(xlim = c(0, 6500)) +
theme_minimal() +
theme(
legend.position = "none",
panel.grid.major = element_line(color = "grey80"),
panel.grid.minor = element_blank(),
axis.text.y = element_text(size = 10),
axis.text.x = element_text(size = 10)
)
# covid + distance
combined_data <- covid_2020 |>
inner_join(happiness, by = "country") |>
select(country, total_cases, distance_to_equator_km)
combined_data <- combined_data |>
filter(
!is.na(total_cases) & !is.na(distance_to_equator_km),
is.finite(total_cases) & is.finite(distance_to_equator_km),
total_cases <= 50000000
)
combined_data
ggplot(combined_data, aes(x = distance_to_equator_km, y = total_cases)) +
geom_hex() +
geom_smooth(method = "lm", color = "red", se = TRUE) +
labs(
title = "Comparison of COVID-19 Cases and Distance from Equator",
x = "Distance from Equator (km)",
y = "Total COVID-19 Cases"
) +
scale_y_continuous(labels = comma) +
scale_fill_viridis_c() +
theme_minimal()
colnames(happiness)
ggplot(combined_data, aes(x = distance_to_equator_km)) +
geom_histogram(binwidth = 500, fill = "steelblue", color = "black") +
annotate("rect", xmin = 1500, xmax = 2500, ymin = 0, ymax = Inf, fill = "orange", alpha = 0.8) +
labs(
title = "Histogram of Distance from Equator by COVID-19 Cases",
x = "Distance from Equator (km)",
y = "Number of Countries"
) +
coord_cartesian(xlim = c(0, 10250)) +
theme_minimal()
nah <- ggplot(cyclones_data, aes(x = km_distance_from_equator)) +
geom_histogram(binwidth = 500, fill = "steelblue", color = "black") +
annotate("rect", xmin = 1500, xmax = 2500, ymin = 0, ymax = Inf, fill = "orange", alpha = 0.8) +
labs(
title = "Histogram of Distance from Equator for All Cyclones",
x = "Distance from Equator (km)",
y = "Number of Cyclones"
) +
coord_cartesian(xlim = c(0, 10250)) +
theme_minimal() +
theme(
panel.grid.major = element_line(color = "grey80"),
panel.grid.minor = element_blank(),
axis.text.y = element_text(size = 10),
axis.text.x = element_text(size = 10)
)
ggplot(cyclones_data |> filter(!is.na(category)), aes(x = km_distance_from_equator, y = category, fill = category)) +
geom_density_ridges(scale = 2, alpha = 0.7, color = "black") +
annotate("rect", xmin = 1500, xmax = 2500, ymin = 0, ymax = Inf, fill = "orange", alpha = 0.8) +
labs(
x = "Distance from Equator (km)",
y = "Cyclone Category",
title = "Ridgeline Plot of Distance from Equator by Cyclone Category"
) +
coord_cartesian(xlim = c(0, 6500)) +
theme_minimal() +
theme(
legend.position = "none",
panel.grid.major = element_line(color = "grey80"),
panel.grid.minor = element_blank(),
axis.text.y = element_text(size = 10),
axis.text.x = element_text(size = 10)
)
happiness <- happiness|>
left_join(
rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") |>
transmute(
country = name_long,
distance_to_equator_km = geosphere::distGeo(
cbind(st_coordinates(st_centroid(geometry))[,1], st_coordinates(st_centroid(geometry))[,2]),
cbind(st_coordinates(st_centroid(geometry))[,1], 0)
) / 1000  # Convert to km
),
by = "country"
)
happiness
happiness_bands_gdp <- happiness |>
mutate(distance_band = cut(distance_to_equator_km.y, breaks = seq(0, 10000, by = 500), include.lowest = TRUE, labels = seq(0, 9500, by = 500))) |>
group_by(distance_band) |>
summarize(avg_log_gdp_per_capita = mean(log_gdp_per_capita, na.rm = TRUE))
# Plot for log GDP per capita
ggplot(happiness_bands_gdp, aes(x = distance_band, y = avg_log_gdp_per_capita)) +
geom_bar(stat = "identity", fill = "steelblue") +
annotate("rect", xmin = "1500", xmax = "2500", ymin = 0, ymax = Inf, fill = "orange", alpha = 0.8) +
labs(
title = "Average GDP per Capita by Distance from Equator",
x = "Distance from Equator (km, Binned)",
y = "Average Log GDP per Capita"
) +
scale_x_discrete(breaks = seq(0, 9500, by = 1000)) +
coord_cartesian(ylim = c(min(happiness_bands_gdp$avg_log_gdp_per_capita, na.rm = TRUE) - 0.1,
max(happiness_bands_gdp$avg_log_gdp_per_capita, na.rm = TRUE) + 0.1)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
# Group data into 500 km distance bands and calculate average life ladder score for each band
happiness_bands_life <- happiness |>
mutate(distance_band = cut(distance_to_equator_km.y, breaks = seq(0, 10000, by = 500), include.lowest = TRUE, labels = seq(0, 9500, by = 500))) %>%
group_by(distance_band) |>
summarize(avg_life_ladder = mean(life_ladder, na.rm = TRUE))
# Plot for life ladder
ggplot(happiness_bands_life, aes(x = distance_band, y = avg_life_ladder)) +
geom_bar(stat = "identity", fill = "steelblue") +
annotate("rect", xmin = "1500", xmax = "2500", ymin = 0, ymax = Inf, fill = "orange", alpha = 0.8) +
labs(
title = "Average Life Ladder Score by Distance from Equator",
x = "Distance from Equator (km, Binned)",
y = "Average Life Ladder Score"
) +
scale_x_discrete(breaks = seq(0, 9500, by = 1000)) +
coord_cartesian(ylim = c(min(happiness_bands_life$avg_life_ladder, na.rm = TRUE) - 0.1,
max(happiness_bands_life$avg_life_ladder, na.rm = TRUE) + 0.1)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
